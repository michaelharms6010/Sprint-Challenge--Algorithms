# Analysis of Algorithms

## Exercise I

Give an analysis of the running time of each snippet of
pseudocode with respect to the input size n of each of the following:

```python
a)  a = 0
    while (a < n * n * n):
      a = a + n * n
```
O(1)


```
b)  sum = 0
    for i in range(n):
      j = 1
      while j < n:
        j *= 2
        sum += 1
```
O(n log n) 
for n=1 it runs 0 times, for n=5 it runs 15, for n=20, it runs 100. There is a curve but it's not exponential, so I'm p sure it's O(n log n)

```
c)  def bunnyEars(bunnies):
      if bunnies == 0:
        return 0

      return 2 + bunnyEars(bunnies-1)
```
O(n) - the function runs ~n times.

## Exercise II

Suppose that you have an n-story building and plenty of eggs. Suppose also that an egg gets broken if it is thrown off floor f or higher, and doesn't get broken if dropped off a floor less than floor f. Devise a strategy to determine the value of f such that the number of dropped + broken eggs is minimized.

Write out your proposed algorithm in plain English or pseudocode AND give the runtime complexity of your solution.

Drop an egg midway up

if it doesn't break, go halfway between the midpoint you just dropped form and the top of the building. Repeat process from this new midpoint.

if it breaks, go halfway between the point you just dropped from and the bottom of the building. repeat this process form this new endpoint.

this is like binary search, and has a time complexity of O(log n)